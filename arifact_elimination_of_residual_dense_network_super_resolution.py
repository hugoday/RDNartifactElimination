# -*- coding: utf-8 -*-
"""Arifact Elimination of Residual Dense Network Super-Resolution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g-CKAe4S6AfqRAYSDkk1FMBHXLSGu68E

[![Google Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/idealo/image-super-resolution/blob/master/notebooks/ISR_Prediction_Tutorial.ipynb)

# Install ISR
"""

!pip install 'h5py==2.10.0' --force-reinstall
!pip install tensorflow_core
!pip install ISR==2.0.0

"""# Predict

Download a sample image
"""

!wget http://images.math.cnrs.fr/IMG/png/section8-image.png
!mkdir -p data/input/test_images
!mv *.png data/input/test_images

"""Load the image with PIL"""

import numpy as np
from PIL import Image

img = Image.open('data/input/test_images/section8-image.png')
# img = Image.open('path/to/your/image.png')
img

"""## Get predictions

### Create the model and run prediction
Create a RDN model with the provided pre-trained weights
"""

from ISR.models import RRDN

model = RRDN(weights='gans')

"""#### Baseline

Bicubic upscaling
"""

bicubic = img.resize(size=(img.size[0]*4, img.size[1]*4), resample=Image.BICUBIC)

"""RDN"""

img = img.convert("RGB")
sr_img = model.predict(np.array(img))
Image.fromarray(sr_img)

"""### Artifact elimination
Use rotation and averaging to remove upscaling artifacts
"""

from tensorflow_core import data
from skimage.metrics import structural_similarity as compare_ssim
import argparse
import imutils
import cv2
import numpy
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import math

img = img.convert("RGB")
sr_img = model.predict(np.array(img))

bicubic = img.resize(size=(img.size[0]*4, img.size[1]*4), resample=Image.BICUBIC)
resample = img.resize((img.size[0]*4, img.size[1]*4))
sr = cv2.cvtColor(numpy.array(sr_img), cv2.COLOR_RGB2BGR)
input = cv2.cvtColor(numpy.array(img), cv2.COLOR_RGB2BGR)

outputs = []

top = math.ceil(abs(input.shape[0] * math.sin(45)) + abs(input.shape[1] * math.cos(45)) - input.shape[0])
side = math.ceil(abs(input.shape[0] * math.cos(45)) + abs(input.shape[1] * math.sin(45)) - input.shape[1])

sr_border = cv2.copyMakeBorder(input, top, top, side, side, cv2.BORDER_CONSTANT, value=[0,0,0])

for angle in [0, 10, 30, 45]:
  print(f"Upscaling at {angle} degrees... ", end='')


  rotated = imutils.rotate(sr_border, angle)

  sr_rot = np.array(model.predict(rotated))

  sr_new = imutils.rotate(sr_rot, -1*angle)
  cropW = (sr_new.shape[1]-sr.shape[1])//2;
  cropH = (sr_new.shape[0]-sr.shape[0])//2;
  sr_new = sr_new[cropH:(sr_new.shape[0]-cropH), cropW:(sr_new.shape[1]-cropW)]
  print("[DONE]")
  
  assert sr_new.shape == sr.shape, f"Expected output of shape {sr.shape} but got output of shape {sr_new.shape}"
  outputs.append(sr_new)

print("Bicubic upscale:")
cv2_imshow( cv2.cvtColor( numpy.array( img.resize(size=(img.size[0]*4, img.size[1]*4), resample=Image.BICUBIC)), cv2.COLOR_RGB2BGR) )

print("Improved RDN upscale:")
sr_new = np.average(outputs, axis=0)
cv2_imshow(sr_new)